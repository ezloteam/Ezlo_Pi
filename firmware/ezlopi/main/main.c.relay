#include <stdio.h>
#include "nvs.h"
#include "nvs_flash.h"
#include "esp_system.h"
#include "driver/adc.h"
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "mbedtls/config.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "ezlopi_timer.h"
#include "timer_service.h"
#include "gpio_isr_service.h"
#include "ezlopi_event_queue.h"

#include "trace.h"
#include "ezlopi.h"
#include "qt_serial.h"
#include "web_provisioning.h"
#include "gpio_isr_service.h"
#include "ezlopi_ble_service.h"
#include "ezlopi_system_info.h"

static void blinky(void *pv);

#define RELAY_GPIO(X) (1ull << X)

static const uint64_t relay_gpios = RELAY_GPIO(4) | RELAY_GPIO(5) | RELAY_GPIO(6) | RELAY_GPIO(7) | RELAY_GPIO(8) | RELAY_GPIO(9);
gpio_config_t relay_gpio_conf = {
    .pin_bit_mask = relay_gpios,
    .mode = GPIO_MODE_OUTPUT,
    .pull_up_en = GPIO_PULLUP_DISABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_DISABLE,
};

void app_main(void)
{
    // qt_serial_init();
    // gpio_isr_service_init();
    // ezlopi_init();
    // web_provisioning_init();
    // ezlopi_ble_service_init();
    // timer_service_init();
    // TRACE_B("Boot count: %d", ezlopi_system_info_get_boot_count());
    xTaskCreate(blinky, "blinky", 2 * 2048, NULL, 1, NULL);
}

typedef enum e_relay_name
{
    Y1_RELAY_O_0 = 0,
    G__RELAY_O_1,
    W1_RELAY_O_2,
    B__RELAY_O_3,
    O__RELAY_O_4,
    W2_RELAY_O_5,
    Y2_RELAY_O_6,
} e_relay_name_t;

typedef struct s_relay_list
{
    e_relay_name_t relay;
    char *name;
} s_relay_list_t;

static const s_relay_list_t relay_list[] = {
    {.name = "Y1_RELAY_O_0", .relay = Y1_RELAY_O_0},
    {.name = "G__RELAY_O_1", .relay = G__RELAY_O_1},
    {.name = "W1_RELAY_O_2", .relay = W1_RELAY_O_2},
    {.name = "B__RELAY_O_3", .relay = B__RELAY_O_3},
    {.name = "O__RELAY_O_4", .relay = O__RELAY_O_4},
    {.name = "W2_RELAY_O_5", .relay = W2_RELAY_O_5},
    {.name = "Y2_RELAY_O_6", .relay = Y2_RELAY_O_6},
};

static void relay_address(e_relay_name_t relay)
{
    gpio_set_level(7, (0x01 & relay));
    gpio_set_level(8, (0x02 & relay));
    gpio_set_level(9, (0x04 & relay));
}

static void relay_set(void)
{
    gpio_set_level(4, 1); // Set
    gpio_set_level(5, 0); // Re-set
    gpio_set_level(6, 1); // STS
}

static void relay_reset(void)
{
    gpio_set_level(4, 0); // Set
    gpio_set_level(5, 1); // Re-set
    gpio_set_level(6, 1); // STS
}

static void relay_photo_coupler(void)
{
    gpio_set_level(4, 0); // Set
    gpio_set_level(5, 0); // Re-set
    gpio_set_level(6, 0); // STS
}

static void blinky(void *pv)
{
    // gpio_config_t io_conf = {
    //     .pin_bit_mask = (1ULL << GPIO_NUM_2),
    //     .mode = GPIO_MODE_OUTPUT,
    //     .pull_up_en = GPIO_PULLUP_DISABLE,
    //     .pull_down_en = GPIO_PULLDOWN_DISABLE,
    //     .intr_type = GPIO_INTR_DISABLE,
    // };

    // uint32_t state = 0;
    uint32_t count = 0;

    // adc1_config_width(ADC_WIDTH_BIT_12);
    // gpio_config(&io_conf);
    gpio_config(&relay_gpio_conf);
    uint32_t relay_count = 0;

    while (1)
    {
        // state ^= 1;
        // gpio_set_level(GPIO_NUM_2, state);
        // int hall_sensor_value = hall_sensor_read();
        // int hall_sensor_value = 0;
        // TRACE_D("Hall Sensor value: %d\r\n", hall_sensor_value);

        if (0 == (count % 10))
        {
            TRACE_D("Selected relay[%d]: %s", relay_count % 7, relay_list[relay_count % 7].name);
            relay_address(relay_list[relay_count].relay);

            relay_reset();
            TRACE_D("Reset");
            vTaskDelay(5000 / portTICK_RATE_MS);
            relay_set();
            TRACE_D("Set");
            vTaskDelay(5000 / portTICK_RATE_MS);
            relay_photo_coupler();
            TRACE_D("Opto");
            vTaskDelay(5000 / portTICK_RATE_MS);

            relay_count = (++relay_count > 6) ? 0 : relay_count;
        }

        if (0 == (count % 2))
        {
            TRACE_D("-----------------------------------------");
            TRACE_D("esp_get_free_heap_size - %d", esp_get_free_heap_size());
            TRACE_D("esp_get_minimum_free_heap_size: %u", esp_get_minimum_free_heap_size());
            TRACE_D("-----------------------------------------");
        }

        vTaskDelay(1000 / portTICK_RATE_MS);
    }
}
